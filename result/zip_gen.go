// Code generated by generate_zip.pl; DO NOT EDIT.

package result

import (
	"github.com/shogo82148/hi/tuple"
)

// Zip2 returns an optional of valid 2-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip2[T1, T2 any](o1 Result[T1], o2 Result[T2]) Result[tuple.Tuple2[T1, T2]] {
	if o1.err == nil && o2.err == nil {
		return Result[tuple.Tuple2[T1, T2]]{value: tuple.Tuple2[T1, T2]{V1: o1.value, V2: o2.value}}
	} else {
		errs := make([]error, 0, 2)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		return Result[tuple.Tuple2[T1, T2]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}

// Zip3 returns an optional of valid 3-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip3[T1, T2, T3 any](o1 Result[T1], o2 Result[T2], o3 Result[T3]) Result[tuple.Tuple3[T1, T2, T3]] {
	if o1.err == nil && o2.err == nil && o3.err == nil {
		return Result[tuple.Tuple3[T1, T2, T3]]{value: tuple.Tuple3[T1, T2, T3]{V1: o1.value, V2: o2.value, V3: o3.value}}
	} else {
		errs := make([]error, 0, 3)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		if o3.err != nil {
			errs = append(errs, o3.err)
		}
		return Result[tuple.Tuple3[T1, T2, T3]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}

// Zip4 returns an optional of valid 4-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip4[T1, T2, T3, T4 any](o1 Result[T1], o2 Result[T2], o3 Result[T3], o4 Result[T4]) Result[tuple.Tuple4[T1, T2, T3, T4]] {
	if o1.err == nil && o2.err == nil && o3.err == nil && o4.err == nil {
		return Result[tuple.Tuple4[T1, T2, T3, T4]]{value: tuple.Tuple4[T1, T2, T3, T4]{V1: o1.value, V2: o2.value, V3: o3.value, V4: o4.value}}
	} else {
		errs := make([]error, 0, 4)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		if o3.err != nil {
			errs = append(errs, o3.err)
		}
		if o4.err != nil {
			errs = append(errs, o4.err)
		}
		return Result[tuple.Tuple4[T1, T2, T3, T4]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}

// Zip5 returns an optional of valid 5-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip5[T1, T2, T3, T4, T5 any](o1 Result[T1], o2 Result[T2], o3 Result[T3], o4 Result[T4], o5 Result[T5]) Result[tuple.Tuple5[T1, T2, T3, T4, T5]] {
	if o1.err == nil && o2.err == nil && o3.err == nil && o4.err == nil && o5.err == nil {
		return Result[tuple.Tuple5[T1, T2, T3, T4, T5]]{value: tuple.Tuple5[T1, T2, T3, T4, T5]{V1: o1.value, V2: o2.value, V3: o3.value, V4: o4.value, V5: o5.value}}
	} else {
		errs := make([]error, 0, 5)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		if o3.err != nil {
			errs = append(errs, o3.err)
		}
		if o4.err != nil {
			errs = append(errs, o4.err)
		}
		if o5.err != nil {
			errs = append(errs, o5.err)
		}
		return Result[tuple.Tuple5[T1, T2, T3, T4, T5]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}

// Zip6 returns an optional of valid 6-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip6[T1, T2, T3, T4, T5, T6 any](o1 Result[T1], o2 Result[T2], o3 Result[T3], o4 Result[T4], o5 Result[T5], o6 Result[T6]) Result[tuple.Tuple6[T1, T2, T3, T4, T5, T6]] {
	if o1.err == nil && o2.err == nil && o3.err == nil && o4.err == nil && o5.err == nil && o6.err == nil {
		return Result[tuple.Tuple6[T1, T2, T3, T4, T5, T6]]{value: tuple.Tuple6[T1, T2, T3, T4, T5, T6]{V1: o1.value, V2: o2.value, V3: o3.value, V4: o4.value, V5: o5.value, V6: o6.value}}
	} else {
		errs := make([]error, 0, 6)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		if o3.err != nil {
			errs = append(errs, o3.err)
		}
		if o4.err != nil {
			errs = append(errs, o4.err)
		}
		if o5.err != nil {
			errs = append(errs, o5.err)
		}
		if o6.err != nil {
			errs = append(errs, o6.err)
		}
		return Result[tuple.Tuple6[T1, T2, T3, T4, T5, T6]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}

// Zip7 returns an optional of valid 7-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip7[T1, T2, T3, T4, T5, T6, T7 any](o1 Result[T1], o2 Result[T2], o3 Result[T3], o4 Result[T4], o5 Result[T5], o6 Result[T6], o7 Result[T7]) Result[tuple.Tuple7[T1, T2, T3, T4, T5, T6, T7]] {
	if o1.err == nil && o2.err == nil && o3.err == nil && o4.err == nil && o5.err == nil && o6.err == nil && o7.err == nil {
		return Result[tuple.Tuple7[T1, T2, T3, T4, T5, T6, T7]]{value: tuple.Tuple7[T1, T2, T3, T4, T5, T6, T7]{V1: o1.value, V2: o2.value, V3: o3.value, V4: o4.value, V5: o5.value, V6: o6.value, V7: o7.value}}
	} else {
		errs := make([]error, 0, 7)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		if o3.err != nil {
			errs = append(errs, o3.err)
		}
		if o4.err != nil {
			errs = append(errs, o4.err)
		}
		if o5.err != nil {
			errs = append(errs, o5.err)
		}
		if o6.err != nil {
			errs = append(errs, o6.err)
		}
		if o7.err != nil {
			errs = append(errs, o7.err)
		}
		return Result[tuple.Tuple7[T1, T2, T3, T4, T5, T6, T7]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}

// Zip8 returns an optional of valid 8-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip8[T1, T2, T3, T4, T5, T6, T7, T8 any](o1 Result[T1], o2 Result[T2], o3 Result[T3], o4 Result[T4], o5 Result[T5], o6 Result[T6], o7 Result[T7], o8 Result[T8]) Result[tuple.Tuple8[T1, T2, T3, T4, T5, T6, T7, T8]] {
	if o1.err == nil && o2.err == nil && o3.err == nil && o4.err == nil && o5.err == nil && o6.err == nil && o7.err == nil && o8.err == nil {
		return Result[tuple.Tuple8[T1, T2, T3, T4, T5, T6, T7, T8]]{value: tuple.Tuple8[T1, T2, T3, T4, T5, T6, T7, T8]{V1: o1.value, V2: o2.value, V3: o3.value, V4: o4.value, V5: o5.value, V6: o6.value, V7: o7.value, V8: o8.value}}
	} else {
		errs := make([]error, 0, 8)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		if o3.err != nil {
			errs = append(errs, o3.err)
		}
		if o4.err != nil {
			errs = append(errs, o4.err)
		}
		if o5.err != nil {
			errs = append(errs, o5.err)
		}
		if o6.err != nil {
			errs = append(errs, o6.err)
		}
		if o7.err != nil {
			errs = append(errs, o7.err)
		}
		if o8.err != nil {
			errs = append(errs, o8.err)
		}
		return Result[tuple.Tuple8[T1, T2, T3, T4, T5, T6, T7, T8]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}

// Zip9 returns an optional of valid 9-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip9[T1, T2, T3, T4, T5, T6, T7, T8, T9 any](o1 Result[T1], o2 Result[T2], o3 Result[T3], o4 Result[T4], o5 Result[T5], o6 Result[T6], o7 Result[T7], o8 Result[T8], o9 Result[T9]) Result[tuple.Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9]] {
	if o1.err == nil && o2.err == nil && o3.err == nil && o4.err == nil && o5.err == nil && o6.err == nil && o7.err == nil && o8.err == nil && o9.err == nil {
		return Result[tuple.Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9]]{value: tuple.Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9]{V1: o1.value, V2: o2.value, V3: o3.value, V4: o4.value, V5: o5.value, V6: o6.value, V7: o7.value, V8: o8.value, V9: o9.value}}
	} else {
		errs := make([]error, 0, 9)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		if o3.err != nil {
			errs = append(errs, o3.err)
		}
		if o4.err != nil {
			errs = append(errs, o4.err)
		}
		if o5.err != nil {
			errs = append(errs, o5.err)
		}
		if o6.err != nil {
			errs = append(errs, o6.err)
		}
		if o7.err != nil {
			errs = append(errs, o7.err)
		}
		if o8.err != nil {
			errs = append(errs, o8.err)
		}
		if o9.err != nil {
			errs = append(errs, o9.err)
		}
		return Result[tuple.Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}

// Zip10 returns an optional of valid 10-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10 any](o1 Result[T1], o2 Result[T2], o3 Result[T3], o4 Result[T4], o5 Result[T5], o6 Result[T6], o7 Result[T7], o8 Result[T8], o9 Result[T9], o10 Result[T10]) Result[tuple.Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]] {
	if o1.err == nil && o2.err == nil && o3.err == nil && o4.err == nil && o5.err == nil && o6.err == nil && o7.err == nil && o8.err == nil && o9.err == nil && o10.err == nil {
		return Result[tuple.Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]]{value: tuple.Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]{V1: o1.value, V2: o2.value, V3: o3.value, V4: o4.value, V5: o5.value, V6: o6.value, V7: o7.value, V8: o8.value, V9: o9.value, V10: o10.value}}
	} else {
		errs := make([]error, 0, 10)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		if o3.err != nil {
			errs = append(errs, o3.err)
		}
		if o4.err != nil {
			errs = append(errs, o4.err)
		}
		if o5.err != nil {
			errs = append(errs, o5.err)
		}
		if o6.err != nil {
			errs = append(errs, o6.err)
		}
		if o7.err != nil {
			errs = append(errs, o7.err)
		}
		if o8.err != nil {
			errs = append(errs, o8.err)
		}
		if o9.err != nil {
			errs = append(errs, o9.err)
		}
		if o10.err != nil {
			errs = append(errs, o10.err)
		}
		return Result[tuple.Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}

// Zip11 returns an optional of valid 11-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11 any](o1 Result[T1], o2 Result[T2], o3 Result[T3], o4 Result[T4], o5 Result[T5], o6 Result[T6], o7 Result[T7], o8 Result[T8], o9 Result[T9], o10 Result[T10], o11 Result[T11]) Result[tuple.Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]] {
	if o1.err == nil && o2.err == nil && o3.err == nil && o4.err == nil && o5.err == nil && o6.err == nil && o7.err == nil && o8.err == nil && o9.err == nil && o10.err == nil && o11.err == nil {
		return Result[tuple.Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]]{value: tuple.Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]{V1: o1.value, V2: o2.value, V3: o3.value, V4: o4.value, V5: o5.value, V6: o6.value, V7: o7.value, V8: o8.value, V9: o9.value, V10: o10.value, V11: o11.value}}
	} else {
		errs := make([]error, 0, 11)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		if o3.err != nil {
			errs = append(errs, o3.err)
		}
		if o4.err != nil {
			errs = append(errs, o4.err)
		}
		if o5.err != nil {
			errs = append(errs, o5.err)
		}
		if o6.err != nil {
			errs = append(errs, o6.err)
		}
		if o7.err != nil {
			errs = append(errs, o7.err)
		}
		if o8.err != nil {
			errs = append(errs, o8.err)
		}
		if o9.err != nil {
			errs = append(errs, o9.err)
		}
		if o10.err != nil {
			errs = append(errs, o10.err)
		}
		if o11.err != nil {
			errs = append(errs, o11.err)
		}
		return Result[tuple.Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}

// Zip12 returns an optional of valid 12-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12 any](o1 Result[T1], o2 Result[T2], o3 Result[T3], o4 Result[T4], o5 Result[T5], o6 Result[T6], o7 Result[T7], o8 Result[T8], o9 Result[T9], o10 Result[T10], o11 Result[T11], o12 Result[T12]) Result[tuple.Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]] {
	if o1.err == nil && o2.err == nil && o3.err == nil && o4.err == nil && o5.err == nil && o6.err == nil && o7.err == nil && o8.err == nil && o9.err == nil && o10.err == nil && o11.err == nil && o12.err == nil {
		return Result[tuple.Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]]{value: tuple.Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]{V1: o1.value, V2: o2.value, V3: o3.value, V4: o4.value, V5: o5.value, V6: o6.value, V7: o7.value, V8: o8.value, V9: o9.value, V10: o10.value, V11: o11.value, V12: o12.value}}
	} else {
		errs := make([]error, 0, 12)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		if o3.err != nil {
			errs = append(errs, o3.err)
		}
		if o4.err != nil {
			errs = append(errs, o4.err)
		}
		if o5.err != nil {
			errs = append(errs, o5.err)
		}
		if o6.err != nil {
			errs = append(errs, o6.err)
		}
		if o7.err != nil {
			errs = append(errs, o7.err)
		}
		if o8.err != nil {
			errs = append(errs, o8.err)
		}
		if o9.err != nil {
			errs = append(errs, o9.err)
		}
		if o10.err != nil {
			errs = append(errs, o10.err)
		}
		if o11.err != nil {
			errs = append(errs, o11.err)
		}
		if o12.err != nil {
			errs = append(errs, o12.err)
		}
		return Result[tuple.Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}

// Zip13 returns an optional of valid 13-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13 any](o1 Result[T1], o2 Result[T2], o3 Result[T3], o4 Result[T4], o5 Result[T5], o6 Result[T6], o7 Result[T7], o8 Result[T8], o9 Result[T9], o10 Result[T10], o11 Result[T11], o12 Result[T12], o13 Result[T13]) Result[tuple.Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]] {
	if o1.err == nil && o2.err == nil && o3.err == nil && o4.err == nil && o5.err == nil && o6.err == nil && o7.err == nil && o8.err == nil && o9.err == nil && o10.err == nil && o11.err == nil && o12.err == nil && o13.err == nil {
		return Result[tuple.Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]]{value: tuple.Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]{V1: o1.value, V2: o2.value, V3: o3.value, V4: o4.value, V5: o5.value, V6: o6.value, V7: o7.value, V8: o8.value, V9: o9.value, V10: o10.value, V11: o11.value, V12: o12.value, V13: o13.value}}
	} else {
		errs := make([]error, 0, 13)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		if o3.err != nil {
			errs = append(errs, o3.err)
		}
		if o4.err != nil {
			errs = append(errs, o4.err)
		}
		if o5.err != nil {
			errs = append(errs, o5.err)
		}
		if o6.err != nil {
			errs = append(errs, o6.err)
		}
		if o7.err != nil {
			errs = append(errs, o7.err)
		}
		if o8.err != nil {
			errs = append(errs, o8.err)
		}
		if o9.err != nil {
			errs = append(errs, o9.err)
		}
		if o10.err != nil {
			errs = append(errs, o10.err)
		}
		if o11.err != nil {
			errs = append(errs, o11.err)
		}
		if o12.err != nil {
			errs = append(errs, o12.err)
		}
		if o13.err != nil {
			errs = append(errs, o13.err)
		}
		return Result[tuple.Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}

// Zip14 returns an optional of valid 14-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14 any](o1 Result[T1], o2 Result[T2], o3 Result[T3], o4 Result[T4], o5 Result[T5], o6 Result[T6], o7 Result[T7], o8 Result[T8], o9 Result[T9], o10 Result[T10], o11 Result[T11], o12 Result[T12], o13 Result[T13], o14 Result[T14]) Result[tuple.Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]] {
	if o1.err == nil && o2.err == nil && o3.err == nil && o4.err == nil && o5.err == nil && o6.err == nil && o7.err == nil && o8.err == nil && o9.err == nil && o10.err == nil && o11.err == nil && o12.err == nil && o13.err == nil && o14.err == nil {
		return Result[tuple.Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]]{value: tuple.Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]{V1: o1.value, V2: o2.value, V3: o3.value, V4: o4.value, V5: o5.value, V6: o6.value, V7: o7.value, V8: o8.value, V9: o9.value, V10: o10.value, V11: o11.value, V12: o12.value, V13: o13.value, V14: o14.value}}
	} else {
		errs := make([]error, 0, 14)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		if o3.err != nil {
			errs = append(errs, o3.err)
		}
		if o4.err != nil {
			errs = append(errs, o4.err)
		}
		if o5.err != nil {
			errs = append(errs, o5.err)
		}
		if o6.err != nil {
			errs = append(errs, o6.err)
		}
		if o7.err != nil {
			errs = append(errs, o7.err)
		}
		if o8.err != nil {
			errs = append(errs, o8.err)
		}
		if o9.err != nil {
			errs = append(errs, o9.err)
		}
		if o10.err != nil {
			errs = append(errs, o10.err)
		}
		if o11.err != nil {
			errs = append(errs, o11.err)
		}
		if o12.err != nil {
			errs = append(errs, o12.err)
		}
		if o13.err != nil {
			errs = append(errs, o13.err)
		}
		if o14.err != nil {
			errs = append(errs, o14.err)
		}
		return Result[tuple.Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}

// Zip15 returns an optional of valid 15-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15 any](o1 Result[T1], o2 Result[T2], o3 Result[T3], o4 Result[T4], o5 Result[T5], o6 Result[T6], o7 Result[T7], o8 Result[T8], o9 Result[T9], o10 Result[T10], o11 Result[T11], o12 Result[T12], o13 Result[T13], o14 Result[T14], o15 Result[T15]) Result[tuple.Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]] {
	if o1.err == nil && o2.err == nil && o3.err == nil && o4.err == nil && o5.err == nil && o6.err == nil && o7.err == nil && o8.err == nil && o9.err == nil && o10.err == nil && o11.err == nil && o12.err == nil && o13.err == nil && o14.err == nil && o15.err == nil {
		return Result[tuple.Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]]{value: tuple.Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]{V1: o1.value, V2: o2.value, V3: o3.value, V4: o4.value, V5: o5.value, V6: o6.value, V7: o7.value, V8: o8.value, V9: o9.value, V10: o10.value, V11: o11.value, V12: o12.value, V13: o13.value, V14: o14.value, V15: o15.value}}
	} else {
		errs := make([]error, 0, 15)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		if o3.err != nil {
			errs = append(errs, o3.err)
		}
		if o4.err != nil {
			errs = append(errs, o4.err)
		}
		if o5.err != nil {
			errs = append(errs, o5.err)
		}
		if o6.err != nil {
			errs = append(errs, o6.err)
		}
		if o7.err != nil {
			errs = append(errs, o7.err)
		}
		if o8.err != nil {
			errs = append(errs, o8.err)
		}
		if o9.err != nil {
			errs = append(errs, o9.err)
		}
		if o10.err != nil {
			errs = append(errs, o10.err)
		}
		if o11.err != nil {
			errs = append(errs, o11.err)
		}
		if o12.err != nil {
			errs = append(errs, o12.err)
		}
		if o13.err != nil {
			errs = append(errs, o13.err)
		}
		if o14.err != nil {
			errs = append(errs, o14.err)
		}
		if o15.err != nil {
			errs = append(errs, o15.err)
		}
		return Result[tuple.Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}

// Zip16 returns an optional of valid 16-tuples, if all of arguments are valid.
// Otherwise, one or more arguments are not valid, it returns none
func Zip16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16 any](o1 Result[T1], o2 Result[T2], o3 Result[T3], o4 Result[T4], o5 Result[T5], o6 Result[T6], o7 Result[T7], o8 Result[T8], o9 Result[T9], o10 Result[T10], o11 Result[T11], o12 Result[T12], o13 Result[T13], o14 Result[T14], o15 Result[T15], o16 Result[T16]) Result[tuple.Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]] {
	if o1.err == nil && o2.err == nil && o3.err == nil && o4.err == nil && o5.err == nil && o6.err == nil && o7.err == nil && o8.err == nil && o9.err == nil && o10.err == nil && o11.err == nil && o12.err == nil && o13.err == nil && o14.err == nil && o15.err == nil && o16.err == nil {
		return Result[tuple.Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]]{value: tuple.Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]{V1: o1.value, V2: o2.value, V3: o3.value, V4: o4.value, V5: o5.value, V6: o6.value, V7: o7.value, V8: o8.value, V9: o9.value, V10: o10.value, V11: o11.value, V12: o12.value, V13: o13.value, V14: o14.value, V15: o15.value, V16: o16.value}}
	} else {
		errs := make([]error, 0, 16)
		if o1.err != nil {
			errs = append(errs, o1.err)
		}
		if o2.err != nil {
			errs = append(errs, o2.err)
		}
		if o3.err != nil {
			errs = append(errs, o3.err)
		}
		if o4.err != nil {
			errs = append(errs, o4.err)
		}
		if o5.err != nil {
			errs = append(errs, o5.err)
		}
		if o6.err != nil {
			errs = append(errs, o6.err)
		}
		if o7.err != nil {
			errs = append(errs, o7.err)
		}
		if o8.err != nil {
			errs = append(errs, o8.err)
		}
		if o9.err != nil {
			errs = append(errs, o9.err)
		}
		if o10.err != nil {
			errs = append(errs, o10.err)
		}
		if o11.err != nil {
			errs = append(errs, o11.err)
		}
		if o12.err != nil {
			errs = append(errs, o12.err)
		}
		if o13.err != nil {
			errs = append(errs, o13.err)
		}
		if o14.err != nil {
			errs = append(errs, o14.err)
		}
		if o15.err != nil {
			errs = append(errs, o15.err)
		}
		if o16.err != nil {
			errs = append(errs, o16.err)
		}
		return Result[tuple.Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]]{
			err: &wrapErrors{msg: "result: errors", errs: errs},
		}
	}
}
