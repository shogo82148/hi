// Code generated by generate_zip.pl; DO NOT EDIT.

package hi

import (
	"github.com/shogo82148/hi/tuple"
)

// Zip2 returns a slice of 2-tuples.
// The returned slice have the length of the shortest slice.
func Zip2[T1, T2 any](s1 []T1, s2 []T2) []tuple.Tuple2[T1, T2] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	ret := make([]tuple.Tuple2[T1, T2], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple2[T1, T2]{V1: s1[i], V2: s2[i]}
	}
	return ret
}

// Zip3 returns a slice of 3-tuples.
// The returned slice have the length of the shortest slice.
func Zip3[T1, T2, T3 any](s1 []T1, s2 []T2, s3 []T3) []tuple.Tuple3[T1, T2, T3] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	ret := make([]tuple.Tuple3[T1, T2, T3], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple3[T1, T2, T3]{V1: s1[i], V2: s2[i], V3: s3[i]}
	}
	return ret
}

// Zip4 returns a slice of 4-tuples.
// The returned slice have the length of the shortest slice.
func Zip4[T1, T2, T3, T4 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4) []tuple.Tuple4[T1, T2, T3, T4] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	ret := make([]tuple.Tuple4[T1, T2, T3, T4], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple4[T1, T2, T3, T4]{V1: s1[i], V2: s2[i], V3: s3[i], V4: s4[i]}
	}
	return ret
}

// Zip5 returns a slice of 5-tuples.
// The returned slice have the length of the shortest slice.
func Zip5[T1, T2, T3, T4, T5 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5) []tuple.Tuple5[T1, T2, T3, T4, T5] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	ret := make([]tuple.Tuple5[T1, T2, T3, T4, T5], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple5[T1, T2, T3, T4, T5]{V1: s1[i], V2: s2[i], V3: s3[i], V4: s4[i], V5: s5[i]}
	}
	return ret
}

// Zip6 returns a slice of 6-tuples.
// The returned slice have the length of the shortest slice.
func Zip6[T1, T2, T3, T4, T5, T6 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6) []tuple.Tuple6[T1, T2, T3, T4, T5, T6] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	ret := make([]tuple.Tuple6[T1, T2, T3, T4, T5, T6], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple6[T1, T2, T3, T4, T5, T6]{V1: s1[i], V2: s2[i], V3: s3[i], V4: s4[i], V5: s5[i], V6: s6[i]}
	}
	return ret
}

// Zip7 returns a slice of 7-tuples.
// The returned slice have the length of the shortest slice.
func Zip7[T1, T2, T3, T4, T5, T6, T7 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7) []tuple.Tuple7[T1, T2, T3, T4, T5, T6, T7] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	ret := make([]tuple.Tuple7[T1, T2, T3, T4, T5, T6, T7], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple7[T1, T2, T3, T4, T5, T6, T7]{V1: s1[i], V2: s2[i], V3: s3[i], V4: s4[i], V5: s5[i], V6: s6[i], V7: s7[i]}
	}
	return ret
}

// Zip8 returns a slice of 8-tuples.
// The returned slice have the length of the shortest slice.
func Zip8[T1, T2, T3, T4, T5, T6, T7, T8 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8) []tuple.Tuple8[T1, T2, T3, T4, T5, T6, T7, T8] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	ret := make([]tuple.Tuple8[T1, T2, T3, T4, T5, T6, T7, T8], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple8[T1, T2, T3, T4, T5, T6, T7, T8]{V1: s1[i], V2: s2[i], V3: s3[i], V4: s4[i], V5: s5[i], V6: s6[i], V7: s7[i], V8: s8[i]}
	}
	return ret
}

// Zip9 returns a slice of 9-tuples.
// The returned slice have the length of the shortest slice.
func Zip9[T1, T2, T3, T4, T5, T6, T7, T8, T9 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9) []tuple.Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	ret := make([]tuple.Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9]{V1: s1[i], V2: s2[i], V3: s3[i], V4: s4[i], V5: s5[i], V6: s6[i], V7: s7[i], V8: s8[i], V9: s9[i]}
	}
	return ret
}

// Zip10 returns a slice of 10-tuples.
// The returned slice have the length of the shortest slice.
func Zip10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10) []tuple.Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	ret := make([]tuple.Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]{V1: s1[i], V2: s2[i], V3: s3[i], V4: s4[i], V5: s5[i], V6: s6[i], V7: s7[i], V8: s8[i], V9: s9[i], V10: s10[i]}
	}
	return ret
}

// Zip11 returns a slice of 11-tuples.
// The returned slice have the length of the shortest slice.
func Zip11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10, s11 []T11) []tuple.Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	if len(s11) < l {
		l = len(s11)
	}
	ret := make([]tuple.Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]{V1: s1[i], V2: s2[i], V3: s3[i], V4: s4[i], V5: s5[i], V6: s6[i], V7: s7[i], V8: s8[i], V9: s9[i], V10: s10[i], V11: s11[i]}
	}
	return ret
}

// Zip12 returns a slice of 12-tuples.
// The returned slice have the length of the shortest slice.
func Zip12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10, s11 []T11, s12 []T12) []tuple.Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	if len(s11) < l {
		l = len(s11)
	}
	if len(s12) < l {
		l = len(s12)
	}
	ret := make([]tuple.Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]{V1: s1[i], V2: s2[i], V3: s3[i], V4: s4[i], V5: s5[i], V6: s6[i], V7: s7[i], V8: s8[i], V9: s9[i], V10: s10[i], V11: s11[i], V12: s12[i]}
	}
	return ret
}

// Zip13 returns a slice of 13-tuples.
// The returned slice have the length of the shortest slice.
func Zip13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10, s11 []T11, s12 []T12, s13 []T13) []tuple.Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	if len(s11) < l {
		l = len(s11)
	}
	if len(s12) < l {
		l = len(s12)
	}
	if len(s13) < l {
		l = len(s13)
	}
	ret := make([]tuple.Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]{V1: s1[i], V2: s2[i], V3: s3[i], V4: s4[i], V5: s5[i], V6: s6[i], V7: s7[i], V8: s8[i], V9: s9[i], V10: s10[i], V11: s11[i], V12: s12[i], V13: s13[i]}
	}
	return ret
}

// Zip14 returns a slice of 14-tuples.
// The returned slice have the length of the shortest slice.
func Zip14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10, s11 []T11, s12 []T12, s13 []T13, s14 []T14) []tuple.Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	if len(s11) < l {
		l = len(s11)
	}
	if len(s12) < l {
		l = len(s12)
	}
	if len(s13) < l {
		l = len(s13)
	}
	if len(s14) < l {
		l = len(s14)
	}
	ret := make([]tuple.Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]{V1: s1[i], V2: s2[i], V3: s3[i], V4: s4[i], V5: s5[i], V6: s6[i], V7: s7[i], V8: s8[i], V9: s9[i], V10: s10[i], V11: s11[i], V12: s12[i], V13: s13[i], V14: s14[i]}
	}
	return ret
}

// Zip15 returns a slice of 15-tuples.
// The returned slice have the length of the shortest slice.
func Zip15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10, s11 []T11, s12 []T12, s13 []T13, s14 []T14, s15 []T15) []tuple.Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	if len(s11) < l {
		l = len(s11)
	}
	if len(s12) < l {
		l = len(s12)
	}
	if len(s13) < l {
		l = len(s13)
	}
	if len(s14) < l {
		l = len(s14)
	}
	if len(s15) < l {
		l = len(s15)
	}
	ret := make([]tuple.Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]{V1: s1[i], V2: s2[i], V3: s3[i], V4: s4[i], V5: s5[i], V6: s6[i], V7: s7[i], V8: s8[i], V9: s9[i], V10: s10[i], V11: s11[i], V12: s12[i], V13: s13[i], V14: s14[i], V15: s15[i]}
	}
	return ret
}

// Zip16 returns a slice of 16-tuples.
// The returned slice have the length of the shortest slice.
func Zip16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10, s11 []T11, s12 []T12, s13 []T13, s14 []T14, s15 []T15, s16 []T16) []tuple.Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	if len(s11) < l {
		l = len(s11)
	}
	if len(s12) < l {
		l = len(s12)
	}
	if len(s13) < l {
		l = len(s13)
	}
	if len(s14) < l {
		l = len(s14)
	}
	if len(s15) < l {
		l = len(s15)
	}
	if len(s16) < l {
		l = len(s16)
	}
	ret := make([]tuple.Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16], l)
	for i := 0; i < l; i++ {
		ret[i] = tuple.Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]{V1: s1[i], V2: s2[i], V3: s3[i], V4: s4[i], V5: s5[i], V6: s6[i], V7: s7[i], V8: s8[i], V9: s9[i], V10: s10[i], V11: s11[i], V12: s12[i], V13: s13[i], V14: s14[i], V15: s15[i], V16: s16[i]}
	}
	return ret
}
