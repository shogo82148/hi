// Code generated by generate_zip.pl; DO NOT EDIT.

package hi

// Zip2 returns a slice of 2-tuples.
// The returned slice have the length of the shortest slice.
func Zip2[S ~[]Tuple2[T1, T2], T1, T2 any](s1 []T1, s2 []T2) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple2[T1, T2]{s1[i], s2[i]}
	}
	return ret
}

// Zip3 returns a slice of 3-tuples.
// The returned slice have the length of the shortest slice.
func Zip3[S ~[]Tuple3[T1, T2, T3], T1, T2, T3 any](s1 []T1, s2 []T2, s3 []T3) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple3[T1, T2, T3]{s1[i], s2[i], s3[i]}
	}
	return ret
}

// Zip4 returns a slice of 4-tuples.
// The returned slice have the length of the shortest slice.
func Zip4[S ~[]Tuple4[T1, T2, T3, T4], T1, T2, T3, T4 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple4[T1, T2, T3, T4]{s1[i], s2[i], s3[i], s4[i]}
	}
	return ret
}

// Zip5 returns a slice of 5-tuples.
// The returned slice have the length of the shortest slice.
func Zip5[S ~[]Tuple5[T1, T2, T3, T4, T5], T1, T2, T3, T4, T5 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple5[T1, T2, T3, T4, T5]{s1[i], s2[i], s3[i], s4[i], s5[i]}
	}
	return ret
}

// Zip6 returns a slice of 6-tuples.
// The returned slice have the length of the shortest slice.
func Zip6[S ~[]Tuple6[T1, T2, T3, T4, T5, T6], T1, T2, T3, T4, T5, T6 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple6[T1, T2, T3, T4, T5, T6]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i]}
	}
	return ret
}

// Zip7 returns a slice of 7-tuples.
// The returned slice have the length of the shortest slice.
func Zip7[S ~[]Tuple7[T1, T2, T3, T4, T5, T6, T7], T1, T2, T3, T4, T5, T6, T7 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple7[T1, T2, T3, T4, T5, T6, T7]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i], s7[i]}
	}
	return ret
}

// Zip8 returns a slice of 8-tuples.
// The returned slice have the length of the shortest slice.
func Zip8[S ~[]Tuple8[T1, T2, T3, T4, T5, T6, T7, T8], T1, T2, T3, T4, T5, T6, T7, T8 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple8[T1, T2, T3, T4, T5, T6, T7, T8]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i], s7[i], s8[i]}
	}
	return ret
}

// Zip9 returns a slice of 9-tuples.
// The returned slice have the length of the shortest slice.
func Zip9[S ~[]Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9], T1, T2, T3, T4, T5, T6, T7, T8, T9 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i], s7[i], s8[i], s9[i]}
	}
	return ret
}

// Zip10 returns a slice of 10-tuples.
// The returned slice have the length of the shortest slice.
func Zip10[S ~[]Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], T1, T2, T3, T4, T5, T6, T7, T8, T9, T10 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i], s7[i], s8[i], s9[i], s10[i]}
	}
	return ret
}

// Zip11 returns a slice of 11-tuples.
// The returned slice have the length of the shortest slice.
func Zip11[S ~[]Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11], T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10, s11 []T11) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	if len(s11) < l {
		l = len(s11)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i], s7[i], s8[i], s9[i], s10[i], s11[i]}
	}
	return ret
}

// Zip12 returns a slice of 12-tuples.
// The returned slice have the length of the shortest slice.
func Zip12[S ~[]Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12], T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10, s11 []T11, s12 []T12) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	if len(s11) < l {
		l = len(s11)
	}
	if len(s12) < l {
		l = len(s12)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i], s7[i], s8[i], s9[i], s10[i], s11[i], s12[i]}
	}
	return ret
}

// Zip13 returns a slice of 13-tuples.
// The returned slice have the length of the shortest slice.
func Zip13[S ~[]Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13], T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10, s11 []T11, s12 []T12, s13 []T13) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	if len(s11) < l {
		l = len(s11)
	}
	if len(s12) < l {
		l = len(s12)
	}
	if len(s13) < l {
		l = len(s13)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i], s7[i], s8[i], s9[i], s10[i], s11[i], s12[i], s13[i]}
	}
	return ret
}

// Zip14 returns a slice of 14-tuples.
// The returned slice have the length of the shortest slice.
func Zip14[S ~[]Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14], T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10, s11 []T11, s12 []T12, s13 []T13, s14 []T14) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	if len(s11) < l {
		l = len(s11)
	}
	if len(s12) < l {
		l = len(s12)
	}
	if len(s13) < l {
		l = len(s13)
	}
	if len(s14) < l {
		l = len(s14)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i], s7[i], s8[i], s9[i], s10[i], s11[i], s12[i], s13[i], s14[i]}
	}
	return ret
}

// Zip15 returns a slice of 15-tuples.
// The returned slice have the length of the shortest slice.
func Zip15[S ~[]Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15], T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10, s11 []T11, s12 []T12, s13 []T13, s14 []T14, s15 []T15) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	if len(s11) < l {
		l = len(s11)
	}
	if len(s12) < l {
		l = len(s12)
	}
	if len(s13) < l {
		l = len(s13)
	}
	if len(s14) < l {
		l = len(s14)
	}
	if len(s15) < l {
		l = len(s15)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i], s7[i], s8[i], s9[i], s10[i], s11[i], s12[i], s13[i], s14[i], s15[i]}
	}
	return ret
}

// Zip16 returns a slice of 16-tuples.
// The returned slice have the length of the shortest slice.
func Zip16[S ~[]Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16], T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10, s11 []T11, s12 []T12, s13 []T13, s14 []T14, s15 []T15, s16 []T16) S {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	if len(s11) < l {
		l = len(s11)
	}
	if len(s12) < l {
		l = len(s12)
	}
	if len(s13) < l {
		l = len(s13)
	}
	if len(s14) < l {
		l = len(s14)
	}
	if len(s15) < l {
		l = len(s15)
	}
	if len(s16) < l {
		l = len(s16)
	}
	ret := make(S, l)
	for i := 0; i < l; i++ {
		ret[i] = Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i], s7[i], s8[i], s9[i], s10[i], s11[i], s12[i], s13[i], s14[i], s15[i], s16[i]}
	}
	return ret
}
